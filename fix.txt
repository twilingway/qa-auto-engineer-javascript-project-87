1. Повторяется код в __tests__/index.test.js
const expectedStylish = fs.readFileSync(getFixturePath('stylish.txt'), 'utf-8').trim()

const expectedPlain = fs.readFileSync(getFixturePath('plain.txt'), 'utf-8').trim()

const expectedJson = fs.readFileSync(getFixturePath('json.txt'), 'utf-8').trim()

Полезно реализовать функцию для загрузки фикстур и использовать ее

Пробелы между строками избыточны - обычно пишем плотнее. Пустые строки между функциями и логическими блоками. Например:

const getFixturePath = filename => path.join('fixtures', filename)

const expectedStylish = readFixture('stylish.txt')
const expectedPlain = readFixture('plain.txt')
const expectedJson = readFixture'json.txt')

const formats = ['json', 'yml']

3. Повторяющейся код в /src/index.js
 const fullPath1 = getFullPath(filepath1)
  const fullPath2 = getFullPath(filepath2)

  const data1 = parse(fs.readFileSync(fullPath1, 'utf-8'), getFormat(fullPath1))
  const data2 = parse(fs.readFileSync(fullPath2, 'utf-8'), getFormat(fullPath2))

Нужна функция для чтения файла, которая прочитает и вернет готовые js данные

genDiff- основная функция приложения и ее задача выполнить верхнеуровневые шаги, не погружаясь в детали:

получить данные
получить дерево отличий
вернуть отформатированный вывод
readData (название может отличаться) должна вернуть распарсенный результат

const data1 = readData(filepath1)
const data2 = readData(filepath2)
Важно! Не нужно менять парсер! Надо реализовать в этом же модуле тот функционал, который сейчас в genDiff читает данные. Статья про проектирование функций: https://ru.hexlet.io/blog/posts/sovershennyy-kod-nishodyaschee-i-voshodyaschee-proektirovanie

Совершенный код: нисходящее и восходящее проектирование

Совершенный код: нисходящее и восходящее проектирование
Присоединяйтесь к нашему Telegram-сообществу
К написанию кода можно подходить с двух позиций: сверху-вниз — нисходящее, и снизу-вверх — восходящее. В первом случае сначала реализуется высокоуровневая логика, а затем идет погружение в детали. Во втором – наоборот, сначала реализуются детали, затем общая логика.

В книгах эти подходы часто противопоставляются. Считается, что если выбран один подход, то второй — исключен. Но это не так — в статье я объясню, почему следование только в одном направлении приводит к проблемам.

В основном программисты сходятся во мнении, что разработку нужно вести сверху-вниз. В таком случае фокус находится не на устройстве кода, а на том, как он будет использоваться. Это важно, так как способы использования сильно влияют на интерфейсную часть кода — классы, методы, функции, всё то, с чем взаимодействуют клиенты этого кода.

Разработка через тестирование (TDD) имеет множество плюсов, среди которых выделяют как раз описанное выше. Программист, использующий TDD, встает на место пользователей своего кода, и понимает, как лучше его спроектировать.

При проектировании в обратном направлении возможна ситуация, что делали-делали, а когда начали использовать — поняли, что неудобно. Такой код придется переписывать, хотя этого можно было бы избежать.

Из сказанного выше можно сделать вывод, что на начальном этапе всегда стоит выбирать проектирование сверху-вниз — и это правда. Сначала нужно понять, что от кода требуется и как он будет использоваться, а вот потом начинаются варианты.

В качестве примера возьмем второй проект Хекслета, где разрабатывается библиотека для построения различий между двумя файлами. Если коротко, то весь интерфейс библиотеки — это одна функция, которая принимает на вход два пути до файлов определенных форматов (yml, json, ini) и возвращает описание различий между структурами этих файлов. Вот её использование:

import genDiff from 'differ';
const result = genDiff(pathToFile1, pathToFile2);
console.log(result);
Код выше является примером подхода сверху-вниз. Мы описали то, как она будет использоваться, но ещё не знаем про то, как она будет написана (или уже написана). Самое приятное, что реализовать эту функциональность можно совершенно разными способами, и ни один из них не повлияет на то, как библиотека будет использоваться. Это значит, что мы получили отличную модульность.

Теперь попробуем опуститься на уровень ниже, внутрь этой функции. Одна из первых задач (гипотетически), которые нужно выполнить: прочитать эти файлы. Так как пути до файлов могут быть относительными, то предварительно их нужно нормализовать, то есть получить полный путь до файла (абсолютный). За это отвечает такой код:

import fs from 'fs';
import path from 'path';

export default (path1, path2) => {
  // получаем полный путь, используя текущую рабочую директорию
  const fullPath1 = path.resolve(process.cwd(), path1); 
  const data1 = fs.readFileSync(fullPath1).toString();

  const fullPath2 = path.resolve(process.cwd(), path2); 
  const data2 = fs.readFileSync(fullPath2).toString();

  // остальной код
};
В принципе, этот код можно было бы так и оставить. Он простой, легко читаемый и не содержит никакой условной логики. Однако, программисты любят абстракции, и пытаются их навертеть. Достаточно часто я вижу, что код выше превращается в такое:

import fs from 'fs';
import path from 'path';

const readFiles = (path1, path2) => {
  const fullPath1 = path.resolve(process.cwd(), path1); 
  const data1 = fs.readFileSync(fullPath1).toString();

  const fullPath2 = path.resolve(process.cwd(), path2); 
  const data2 = fs.readFileSync(fullPath2).toString();

  return [data1, data2];
}

export default (path1, path2) => {
  const [data1, data2] = readFiles(path1, path2);

  // остальной код
};
Перед тем, как читать дальше, попробуйте ответить сами себе, что не так с этим кодом?

К сожалению — не так здесь всё. Получившаяся функция слишком специфична. Она завязана ровно на два файла, хотя в её коде нет ничего, что связывало бы эти файлы между собой. Если бы файлов было три, то её пришлось бы переписать, при том, что обработка каждого конкретного файла бы никак не поменялась. А если бы количество файлов могло быть любым?

Подобный код сильно снижает модульность программы. Одни части приложения начинают сильно опираться на другие там, где этого можно было избежать. Как следствие, изменение в одном месте приводит к тому, что код начинает ломаться в другом месте — там, где этого не ожидали.

Вроде бы маленькая функция, а описываемая проблема довольно серьезная. Когда разработчик думает только сверху вниз, он начинает подстраивать модули и функции нижних уровней под верхние уровни, под имеющиеся данные и их структуру. Но внутренний код, как правило, довольно независимый от самого приложения. Функция чтения файла — сама по себе, ей не важно, сколько у нас там файлов.

Попробуем переписать этот код правильно, с выделением хороших абстракций:

import fs from 'fs';
import path from 'path';

const readFile = (path) => {
  const fullPath = path.resolve(process.cwd(), path); 
  const data = fs.readFileSync(fullPath).toString();
  return data;
}

export default (path1, path2) => {
  const data1 = readFile(path1);
  const data2 = readFile(path2);

  // остальной код
};
Потенциально, если бы мы работали с большим числом файлов или даже с заранее неизвестным их количеством, имея на руках хорошую абстракцию, можно было бы сделать так:

const results = paths.map(readFile);
Пример, разобранный в этой статье, — всего лишь один из возможных вариантов неверного проектирования. Иногда бывает так, что сама функция выделена правильно, но её аргументы подстроены под структуры внешнего кода, хотя должно быть наоборот. Периодически я встречаюсь с таким вариантом описания функции genDiff:

genDiff(paths);

То есть вместо двух путей, передается массив. Причём мы точно знаем, что эта функция работает ровно с двумя путями, и других вариантов тут нет. Почему же получается такой код? Дело в том, что эта библиотека используется в исполняемом файле, который читает аргументы командной строки. То есть по сути библиотека становится частью программы, которая работает так:

gendiff path/to/file1 path/to/file2
Аргументы командной строки — это массив. Программист который начинает думать с этого угла, исходит из того, что на вход ему пришел массив с путями, и дальше он начинает подстраивать под это внутренности, то есть функцию genDiff.

4. Опция по умолчанию
/src/index.js
const genDiff = (filepath1, filepath2, formatName) => {

Значение для опции по умолчанию необходимо указать именно здесь - это "значение приложения", не модуля форматера

5. Старое и новое значение
/src/diffBuilder.js

oldValue: data1[key],
newValue: data2[key],

Порядок выполняемых действий

получили файл1 и файл2
из них данные1 и данные2
сравниваем значение1 и значение2
Нет старого или нового значения, так как не было старого/нового файла

6. Проверка на объект
/src/diffBuilder.js

if (_.isObject(data1[key]) && _.isObject(data2[key])) {

Есть ли необходимость проверять значение на принадлежность к объекту? В ТЗ нет работы со вложенными структурами.

Либо в тестах надо добавить проверку вложенных структур, либо привести приложение до уровня ТЗ

7. Консистентность 
/src/parsers.js export default (data, format) => {
/src/formatters/index.js export default (diff, formatName = 'stylish') => {

Для похожих задач ожидается одинаковое решение. Оба модуля (форматер и парсер) реализуют выбор функции для полученного типа (паттерн "фабрика"). Но реализованы различными способами - оба отличные, но надо выбрать один

8. Получение отступов
/src/formatters/stylish.js

const spaceForAddedDeleted = ' '.repeat(level * 4 - 2)
    const spaceForUnchangedNested = ' '.repeat(level * 4)
    const indentForBracket = '    '.repeat(level - 1)

Необходимо реализовать функцию для получения отступов в соответствии с level - это, если оставляем работу с вложенными структурами.

Если остаются только плоские, то большая часть форматтера не требуется и расстановка пробелов упрощается

9. stringify /src/formatters/plain.js
const formatValue = (value) => { ${formatValue(node.value)}` From ${formatValue(node.oldValue)} to ${formatValue(node.newValue)}`

Полезно дать название в одном стиле с функцией в другом форматтере